"""
EVA-X Embedding Chunk Merger

This script merges chunked EVA-X embeddings into consolidated files with 
EVA-X native format for downstream analysis pipelines.

=============================================================================
OVERVIEW
=============================================================================

Merges multiple part*.npz chunk files (output from evax_embedding_extraction.py)
into three consolidated embedding files:
1. CLS embeddings (192/384/768-dim depending on model size)
2. Pooled patch embeddings (192/384/768-dim)
3. Concatenated CLS+Pooled embeddings (384/768/1536-dim)

All outputs are already in EVA-X format from extraction (no conversion needed).

=============================================================================
EVA-X FORMAT SPECIFICATION
=============================================================================

Output .npz files contain two arrays:

1. **filenames**: np.ndarray
   - Shape: (N,)
   - Dtype: Unicode string
   - Content: Array of DICOM IDs

2. **embeddings**: np.ndarray
   - Shape: (N,)
   - Dtype: object
   - Content: Each element is a 1D float array
   - Element shapes depend on model size:
     * Tiny:  [192] per image (CLS or Pooled), [384] (Concat)
     * Small: [384] per image (CLS or Pooled), [768] (Concat)
     * Base:  [768] per image (CLS or Pooled), [1536] (Concat)

=============================================================================
INPUT REQUIREMENTS
=============================================================================

**Input Chunk Files:**
- Naming pattern: `evax_*_part*.npz` (or custom pattern)
- Must contain keys: 'filenames', 'cls_embeddings', 'pooled_patch_embeddings'
- Generated by evax_embedding_extraction.py with extraction_mode='single_combined'

**Expected Chunk Structure:**
Each part*.npz file contains:
- filenames: (N,) string array
- cls_embeddings: (N,) object array, each element shape (D,)
- pooled_patch_embeddings: (N,) object array, each element shape (D,)

=============================================================================
OUTPUT FILES
=============================================================================

Three consolidated .npz files are created:

1. **evax_cls_all.npz**
   - CLS token embeddings only
   - Embedding dimension: 192/384/768 (depends on model size)

2. **evax_pooled_all.npz**
   - Global Average Pooled patch embeddings only
   - Embedding dimension: 192/384/768

3. **evax_concat_all.npz**
   - Concatenated CLS + Pooled embeddings
   - Embedding dimension: 384/768/1536

=============================================================================
USAGE EXAMPLES
=============================================================================

**Basic usage:**
```bash
python merge_evax_embeddings.py \
  --chunk_pattern "/path/to/evax_base_part*.npz" \
  --output_dir "/path/to/output/"
```

**Custom output prefix:**
```bash
python merge_evax_embeddings.py \
  --chunk_pattern "/path/to/chunks/part*.npz" \
  --output_dir "/path/to/output/" \
  --output_prefix "mimic_evax_base"
```

=============================================================================
"""

import glob
import numpy as np
import os
import argparse
from tqdm import tqdm


def parse_args():
    """
    Parse command line arguments for embedding chunk merging.
    
    Returns:
        argparse.Namespace: Parsed arguments
    """
    parser = argparse.ArgumentParser(
        description='Merge EVA-X embedding chunks into consolidated format',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument(
        '--chunk_pattern',
        type=str,
        required=True,
        help='Glob pattern for chunk files (e.g., "/path/to/part*.npz")'
    )
    
    parser.add_argument(
        '--output_dir',
        type=str,
        required=True,
        help='Directory to save merged embedding files'
    )
    
    parser.add_argument(
        '--output_prefix',
        type=str,
        default='evax',
        help='Prefix for output filenames (default: evax)'
    )
    
    parser.add_argument(
        '--verify_dimensions',
        action='store_true',
        help='Verify all embeddings have consistent dimensions'
    )
    
    return parser.parse_args()


def load_chunks(chunk_files):
    """
    Load all chunk files and concatenate embeddings.
    
    Args:
        chunk_files: List of paths to chunk .npz files
        
    Returns:
        tuple: (filenames, cls_obj_array, pooled_obj_array)
            - filenames: (N,) string array
            - cls_obj_array: (N,) object array, each element shape (D,)
            - pooled_obj_array: (N,) object array, each element shape (D,)
    """
    all_filenames = []
    all_cls = []
    all_pooled = []
    
    for chunk_file in tqdm(chunk_files, desc="Loading chunks"):
        data = np.load(chunk_file, allow_pickle=True)
        
        if 'filenames' not in data or 'cls_embeddings' not in data or 'pooled_patch_embeddings' not in data:
            raise KeyError(f"Chunk {chunk_file} missing required keys. "
                         f"Expected: 'filenames', 'cls_embeddings', 'pooled_patch_embeddings'")
        
        all_filenames.extend(data['filenames'])
        all_cls.extend(data['cls_embeddings'])
        all_pooled.extend(data['pooled_patch_embeddings'])
    
    filenames = np.array(all_filenames)
    
    cls_obj_array = np.empty(len(all_cls), dtype=object)
    for i, emb in enumerate(all_cls):
        cls_obj_array[i] = emb
    
    pooled_obj_array = np.empty(len(all_pooled), dtype=object)
    for i, emb in enumerate(all_pooled):
        pooled_obj_array[i] = emb
    
    return filenames, cls_obj_array, pooled_obj_array


def create_concatenated_embeddings(cls_obj_array, pooled_obj_array):
    """
    Create concatenated CLS + Pooled embeddings.
    
    Args:
        cls_obj_array: (N,) object array
        pooled_obj_array: (N,) object array
        
    Returns:
        np.ndarray: (N,) object array with concatenated embeddings
    """
    concat_obj_array = np.empty(len(cls_obj_array), dtype=object)
    
    for i in tqdm(range(len(cls_obj_array)), desc="Concatenating embeddings"):
        cls_emb = cls_obj_array[i]
        pooled_emb = pooled_obj_array[i]
        concat_emb = np.concatenate([cls_emb, pooled_emb])
        concat_obj_array[i] = concat_emb
    
    return concat_obj_array


def save_embedding_file(output_path, filenames, embeddings_obj):
    """
    Save embeddings in EVA-X format.
    
    Args:
        output_path: Path to output .npz file
        filenames: (N,) string array
        embeddings_obj: (N,) object array
    """
    np.savez(output_path, filenames=filenames, embeddings=embeddings_obj)
    
    file_size_mb = os.path.getsize(output_path) / (1024**2)
    print(f"Saved: {os.path.basename(output_path)} ({file_size_mb:.1f} MB)")


def verify_dimensions(cls_obj_array, pooled_obj_array):
    """
    Verify that all embeddings have consistent dimensions.
    
    Args:
        cls_obj_array: (N,) object array
        pooled_obj_array: (N,) object array
        
    Raises:
        ValueError: If dimensions are inconsistent
    """
    cls_dim = cls_obj_array[0].shape[0]
    pooled_dim = pooled_obj_array[0].shape[0]
    
    print(f"\nVerifying dimensions...")
    print(f"Expected CLS dimension: {cls_dim}")
    print(f"Expected Pooled dimension: {pooled_dim}")
    
    for i in range(len(cls_obj_array)):
        if cls_obj_array[i].shape[0] != cls_dim:
            raise ValueError(f"CLS embedding {i} has dimension {cls_obj_array[i].shape[0]}, "
                           f"expected {cls_dim}")
        
        if pooled_obj_array[i].shape[0] != pooled_dim:
            raise ValueError(f"Pooled embedding {i} has dimension {pooled_obj_array[i].shape[0]}, "
                           f"expected {pooled_dim}")
    
    if cls_dim != pooled_dim:
        raise ValueError(f"CLS and Pooled have different dimensions: {cls_dim} vs {pooled_dim}")
    
    print("Dimension verification passed")


def main():
    """
    Main execution function for merging EVA-X embedding chunks.
    """
    args = parse_args()
    
    print("\n" + "="*80)
    print("EVA-X Embedding Chunk Merger")
    print("="*80)
    print(f"Chunk pattern: {args.chunk_pattern}")
    print(f"Output directory: {args.output_dir}")
    print(f"Output prefix: {args.output_prefix}")
    print("="*80 + "\n")
    
    chunk_files = sorted(glob.glob(args.chunk_pattern))
    
    if len(chunk_files) == 0:
        raise FileNotFoundError(f"No chunks found matching pattern: {args.chunk_pattern}")
    
    print(f"Found {len(chunk_files)} chunk files\n")
    
    os.makedirs(args.output_dir, exist_ok=True)
    
    filenames, cls_obj_array, pooled_obj_array = load_chunks(chunk_files)
    
    print(f"\nTotal images: {len(filenames)}")
    print(f"CLS embeddings: {len(cls_obj_array)} (dtype=object)")
    print(f"Pooled embeddings: {len(pooled_obj_array)} (dtype=object)")
    print(f"Sample CLS shape: {cls_obj_array[0].shape}")
    print(f"Sample Pooled shape: {pooled_obj_array[0].shape}")
    
    if args.verify_dimensions:
        verify_dimensions(cls_obj_array, pooled_obj_array)
    
    concat_obj_array = create_concatenated_embeddings(cls_obj_array, pooled_obj_array)
    print(f"Sample Concat shape: {concat_obj_array[0].shape}")
    
    print("\nSaving output files...")
    
    cls_path = os.path.join(args.output_dir, f"{args.output_prefix}_cls_all.npz")
    save_embedding_file(cls_path, filenames, cls_obj_array)
    
    pooled_path = os.path.join(args.output_dir, f"{args.output_prefix}_pooled_all.npz")
    save_embedding_file(pooled_path, filenames, pooled_obj_array)
    
    concat_path = os.path.join(args.output_dir, f"{args.output_prefix}_concat_all.npz")
    save_embedding_file(concat_path, filenames, concat_obj_array)
    
    print("\n" + "="*80)
    print("Merge complete! Files are EVA-X compatible.")
    print("="*80)
    print("\nUsage example:")
    print(f"  data = np.load('{cls_path}', allow_pickle=True)")
    print("  filenames = data['filenames']")
    print("  embeddings = data['embeddings']  # dtype=object")
    print("  single_embedding = embeddings[0]   # shape (D,)")
    print("="*80 + "\n")


if __name__ == "__main__":
    main()